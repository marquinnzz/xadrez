<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Xadrez</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #1a2530 100%);
            min-height: 100vh;
            padding: 20px;
            color: #ecf0f1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            align-items: start;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            grid-column: 1 / -1;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .chess-board {
            width: 560px;
            height: 560px;
            margin: 0 auto;
            border: 4px solid #8b4513;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #8b4513;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: linear-gradient(45deg, #3498db, #2980b9) !important;
        }

        .square.valid-move {
            position: relative;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(46, 204, 113, 0.3);
            border-radius: 50%;
            border: 2px solid #2ecc71;
        }

        .square.castling-move::after {
            content: 'üè∞';
            position: absolute;
            font-size: 24px;
            color: #f39c12;
            z-index: 10;
        }

        .square.check {
            background: linear-gradient(45deg, #e74c3c, #c0392b) !important;
        }

        .piece {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
        }

        .piece.black {
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }

        .piece.white {
            color: #ecf0f1;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .game-info h2 {
            color: #f39c12;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.5rem;
        }

        .status {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1rem;
        }

        .status.check {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .status.checkmate {
            background: linear-gradient(45deg, #e74c3c, #8b0000);
            color: white;
            font-weight: bold;
        }

        .score-board {
            margin: 20px 0;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .captured-pieces {
            margin-top: 20px;
        }

        .captured-pieces h3 {
            color: #f39c12;
            margin-bottom: 10px;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .captured-piece {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0);
            border-radius: 4px;
            font-size: 20px;
        }

        .coordinates {
            position: absolute;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.6);
        }

        .coordinate-file {
            bottom: 2px;
            right: 4px;
        }

        .coordinate-rank {
            top: 2px;
            left: 4px;
        }

        .moved-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border-radius: 50%;
            font-size: 8px;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .chess-board {
                width: 400px;
                height: 400px;
            }
            
            .square {
                width: 50px;
                height: 50px;
                font-size: 30px;
            }
        }

        @media (max-width: 500px) {
            .chess-board {
                width: 320px;
                height: 320px;
            }
            
            .square {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ôî Xadrez Completo ‚ôö</h1>
            <p>Jogo de xadrez com todas as regras oficiais</p>
        </div>

        <div class="chess-board" id="chessBoard">
            <!-- O tabuleiro ser√° gerado via JavaScript -->
        </div>

        <div class="game-info">
            <h2>Informa√ß√µes do Jogo</h2>
            
            <div class="status" id="gameStatus">
                Turno: Brancas
            </div>

            <div class="score-board">
                <div class="score-item">
                    <span>Brancas:</span>
                    <span id="whiteScore">0</span>
                </div>
                <div class="score-item">
                    <span>Pretas:</span>
                    <span id="blackScore">0</span>
                </div>
            </div>

            <div class="captured-pieces">
                <h3>Pe√ßas Capturadas - Brancas</h3>
                <div class="captured-list" id="whiteCaptured"></div>
                
                <h3>Pe√ßas Capturadas - Pretas</h3>
                <div class="captured-list" id="blackCaptured"></div>
                
            </div>

            <div class="controls">
                <button onclick="chessGame.resetGame()">Novo Jogo</button>
                <button onclick="chessGame.undoMove()">Desfazer Jogada</button>
                <button onclick="chessGame.toggleCoordinates()">Mostrar Coordenadas</button>
                <button onclick="chessGame.toggleMoveHistory()">Hist√≥rico de Movimentos</button>
            </div>

            <div id="moveHistory" style="display: none; margin-top: 20px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px;">
                <h3>Hist√≥rico de Movimentos</h3>
                <div id="historyList"></div>
            </div>
        </div>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedPiece = null;
                this.validMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.scores = { white: 0, black: 0 };
                this.checkStatus = { white: false, black: false };
                this.gameOver = false;
                this.showCoordinates = false;
                this.showHistory = false;
                this.movedPieces = new Set(); // Para rastrear pe√ßas que j√° se moveram
                this.initializeBoard();
            }

            createInitialBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            initializeBoard() {
                const boardElement = document.getElementById('chessBoard');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        square.addEventListener('click', () => this.handleSquareClick(row, col));
                        
                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece === piece.toUpperCase() ? 'white' : 'black'}`;
                            pieceElement.textContent = this.getPieceSymbol(piece);
                            square.appendChild(pieceElement);

                            // Adicionar indicador se a pe√ßa j√° se moveu
                            if (this.hasPieceMoved(row, col)) {
                                const movedIndicator = document.createElement('div');
                                movedIndicator.className = 'moved-indicator';
                                square.appendChild(movedIndicator);
                            }
                        }

                        if (this.showCoordinates) {
                            this.addCoordinates(square, row, col);
                        }

                        boardElement.appendChild(square);
                    }
                }
                this.updateGameStatus();
            }

            addCoordinates(square, row, col) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                
                const fileElement = document.createElement('span');
                fileElement.className = 'coordinates coordinate-file';
                fileElement.textContent = files[col];
                
                const rankElement = document.createElement('span');
                rankElement.className = 'coordinates coordinate-rank';
                rankElement.textContent = ranks[row];
                
                square.appendChild(fileElement);
                square.appendChild(rankElement);
            }

            toggleCoordinates() {
                this.showCoordinates = !this.showCoordinates;
                this.initializeBoard();
            }

            toggleMoveHistory() {
                this.showHistory = !this.showHistory;
                const historyElement = document.getElementById('moveHistory');
                historyElement.style.display = this.showHistory ? 'block' : 'none';
                if (this.showHistory) {
                    this.updateMoveHistory();
                }
            }

            getPieceSymbol(piece) {
                const symbols = {
                    'P': '‚ôô', 'p': '‚ôü',
                    'R': '‚ôñ', 'r': '‚ôú',
                    'N': '‚ôò', 'n': '‚ôû',
                    'B': '‚ôó', 'b': '‚ôù',
                    'Q': '‚ôï', 'q': '‚ôõ',
                    'K': '‚ôî', 'k': '‚ôö'
                };
                return symbols[piece] || '';
            }

            hasPieceMoved(row, col) {
                const pieceKey = `${row},${col}`;
                return this.movedPieces.has(pieceKey);
            }

            markPieceAsMoved(row, col) {
                const pieceKey = `${row},${col}`;
                this.movedPieces.add(pieceKey);
            }

            handleSquareClick(row, col) {
                if (this.gameOver) return;

                const piece = this.board[row][col];
                const squareColor = piece === piece?.toUpperCase() ? 'white' : 'black';

                // Se j√° tem uma pe√ßa selecionada
                if (this.selectedPiece) {
                    const [selectedRow, selectedCol] = this.selectedPiece;
                    
                    // Verifica se √© um movimento v√°lido
                    if (this.isValidMove(selectedRow, selectedCol, row, col)) {
                        this.makeMove(selectedRow, selectedCol, row, col);
                        this.clearSelection();
                        return;
                    }
                    
                    // Se clicou na mesma pe√ßa, deseleciona
                    if (selectedRow === row && selectedCol === col) {
                        this.clearSelection();
                        return;
                    }
                }

                // Se n√£o tem pe√ßa selecionada e clicou em uma pe√ßa do jogador atual
                if (piece && ((this.currentPlayer === 'white' && piece === piece.toUpperCase()) || 
                              (this.currentPlayer === 'black' && piece === piece.toLowerCase()))) {
                    this.selectPiece(row, col);
                }
            }

            selectPiece(row, col) {
                this.clearSelection();
                this.selectedPiece = [row, col];
                
                // Destacar a pe√ßa selecionada
                const square = this.getSquareElement(row, col);
                square.classList.add('selected');
                
                // Mostrar movimentos v√°lidos
                this.validMoves = this.getValidMoves(row, col);
                this.validMoves.forEach(([r, c, type]) => {
                    const moveSquare = this.getSquareElement(r, c);
                    if (type === 'castling') {
                        moveSquare.classList.add('castling-move');
                    } else {
                        moveSquare.classList.add('valid-move');
                    }
                });
            }

            clearSelection() {
                if (this.selectedPiece) {
                    const [row, col] = this.selectedPiece;
                    const square = this.getSquareElement(row, col);
                    square.classList.remove('selected');
                }
                
                this.validMoves.forEach(([row, col, type]) => {
                    const square = this.getSquareElement(row, col);
                    square.classList.remove('valid-move');
                    square.classList.remove('castling-move');
                });
                
                this.selectedPiece = null;
                this.validMoves = [];
            }

            getSquareElement(row, col) {
                return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            }

            getValidMoves(row, col) {
                const piece = this.board[row][col];
                const moves = [];
                const isWhite = piece === piece.toUpperCase();
                
                switch (piece.toLowerCase()) {
                    case 'p': // Pe√£o
                        const direction = isWhite ? -1 : 1;
                        const startRow = isWhite ? 6 : 1;
                        
                        // Movimento para frente
                        if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                            moves.push([row + direction, col, 'normal']);
                            
                            // Movimento duplo do primeiro movimento
                            if (row === startRow && !this.board[row + 2 * direction][col]) {
                                moves.push([row + 2 * direction, col, 'normal']);
                            }
                        }
                        
                        // Capturas
                        for (let dc of [-1, 1]) {
                            if (this.isInBounds(row + direction, col + dc)) {
                                const target = this.board[row + direction][col + dc];
                                if (target && ((isWhite && target === target.toLowerCase()) || 
                                              (!isWhite && target === target.toUpperCase()))) {
                                    moves.push([row + direction, col + dc, 'normal']);
                                }
                            }
                        }
                        break;
                        
                    case 'r': // Torre
                        this.addLineMoves(row, col, moves, [[-1, 0], [1, 0], [0, -1], [0, 1]]);
                        break;
                        
                    case 'n': // Cavalo
                        for (let [dr, dc] of [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (this.isValidTarget(newRow, newCol, isWhite)) {
                                moves.push([newRow, newCol, 'normal']);
                            }
                        }
                        break;
                        
                    case 'b': // Bispo
                        this.addLineMoves(row, col, moves, [[-1, -1], [-1, 1], [1, -1], [1, 1]]);
                        break;
                        
                    case 'q': // Rainha
                        this.addLineMoves(row, col, moves, 
                            [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]);
                        break;
                        
                    case 'k': // Rei
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (this.isValidTarget(newRow, newCol, isWhite)) {
                                    moves.push([newRow, newCol, 'normal']);
                                }
                            }
                        }
                        
                        // Adicionar roque se aplic√°vel
                        this.addCastlingMoves(row, col, moves, isWhite);
                        break;
                }
                
                return moves.filter(([newRow, newCol, type]) => {
                    // Verificar se o movimento n√£o deixa o rei em xeque
                    return !this.wouldBeInCheck(row, col, newRow, newCol, isWhite ? 'white' : 'black', type);
                });
            }

            addCastlingMoves(row, col, moves, isWhite) {
                // Verificar se o rei j√° se moveu
                if (this.hasPieceMoved(row, col)) return;
                
                const kingRow = isWhite ? 7 : 0;
                
                // Roque pequeno (lado do rei)
                if (this.canCastle(kingRow, 7, isWhite, 'kingside')) {
                    moves.push([kingRow, 6, 'castling']);
                }
                
                // Roque grande (lado da dama)
                if (this.canCastle(kingRow, 0, isWhite, 'queenside')) {
                    moves.push([kingRow, 2, 'castling']);
                }
            }

            canCastle(kingRow, rookCol, isWhite, side) {
                const rookPiece = isWhite ? 'R' : 'r';
                
                // Verificar se a torre existe e n√£o se moveu
                if (this.board[kingRow][rookCol] !== rookPiece || this.hasPieceMoved(kingRow, rookCol)) {
                    return false;
                }
                
                // Verificar se o rei n√£o est√° em xeque
                if (this.checkStatus[isWhite ? 'white' : 'black']) {
                    return false;
                }
                
                // Verificar casas entre rei e torre
                const startCol = side === 'kingside' ? 5 : 1;
                const endCol = side === 'kingside' ? 6 : 3;
                
                for (let c = startCol; c <= endCol; c++) {
                    // Verificar se n√£o h√° pe√ßas no caminho
                    if (this.board[kingRow][c] !== '') {
                        return false;
                    }
                    
                    // Verificar se o rei n√£o passa por casas atacadas
                    if (c >= 4 && c <= 6) { // Apenas casas que o rei passa
                        if (this.isSquareAttacked(kingRow, c, isWhite ? 'white' : 'black')) {
                            return false;
                        }
                    }
                }
                
                return true;
            }

            addLineMoves(row, col, moves, directions) {
                const piece = this.board[row][col];
                const isWhite = piece === piece.toUpperCase();
                
                for (let [dr, dc] of directions) {
                    let currentRow = row + dr;
                    let currentCol = col + dc;
                    
                    while (this.isInBounds(currentRow, currentCol)) {
                        const target = this.board[currentRow][currentCol];
                        
                        if (!target) {
                            moves.push([currentRow, currentCol, 'normal']);
                        } else {
                            if ((isWhite && target === target.toLowerCase()) || 
                                (!isWhite && target === target.toUpperCase())) {
                                moves.push([currentRow, currentCol, 'normal']);
                            }
                            break;
                        }
                        
                        currentRow += dr;
                        currentCol += dc;
                    }
                }
            }

            isValidTarget(row, col, isWhite) {
                if (!this.isInBounds(row, col)) return false;
                const target = this.board[row][col];
                return !target || (isWhite ? target === target.toLowerCase() : target === target.toUpperCase());
            }

            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            wouldBeInCheck(fromRow, fromCol, toRow, toCol, playerColor, moveType = 'normal') {
                // Simular o movimento
                const tempBoard = JSON.parse(JSON.stringify(this.board));
                
                if (moveType === 'castling') {
                    // Simular roque
                    const isWhite = playerColor === 'white';
                    const kingRow = isWhite ? 7 : 0;
                    
                    if (toCol === 6) { // Roque pequeno
                        tempBoard[kingRow][6] = tempBoard[kingRow][4]; // Rei
                        tempBoard[kingRow][5] = tempBoard[kingRow][7]; // Torre
                        tempBoard[kingRow][4] = '';
                        tempBoard[kingRow][7] = '';
                    } else if (toCol === 2) { // Roque grande
                        tempBoard[kingRow][2] = tempBoard[kingRow][4]; // Rei
                        tempBoard[kingRow][3] = tempBoard[kingRow][0]; // Torre
                        tempBoard[kingRow][4] = '';
                        tempBoard[kingRow][0] = '';
                    }
                } else {
                    // Movimento normal
                    tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
                    tempBoard[fromRow][fromCol] = '';
                }
                
                // Encontrar a posi√ß√£o do rei
                let kingRow, kingCol;
                const kingPiece = playerColor === 'white' ? 'K' : 'k';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (tempBoard[r][c] === kingPiece) {
                            kingRow = r;
                            kingCol = c;
                            break;
                        }
                    }
                }
                
                // Verificar se o rei est√° em xeque
                return this.isSquareAttacked(kingRow, kingCol, playerColor, tempBoard);
            }

            isSquareAttacked(row, col, defenderColor, board = this.board) {
                const attackerColor = defenderColor === 'white' ? 'black' : 'white';
                const isDefenderWhite = defenderColor === 'white';
                
                // Verificar pe√µes
                const pawnDirection = isDefenderWhite ? 1 : -1;
                for (let dc of [-1, 1]) {
                    const attackRow = row + pawnDirection;
                    const attackCol = col + dc;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = board[attackRow][attackCol];
                        if (piece && piece.toLowerCase() === 'p' && 
                            ((isDefenderWhite && piece === piece.toLowerCase()) || 
                             (!isDefenderWhite && piece === piece.toUpperCase()))) {
                            return true;
                        }
                    }
                }
                
                // Verificar cavalos
                for (let [dr, dc] of [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]) {
                    const attackRow = row + dr;
                    const attackCol = col + dc;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = board[attackRow][attackCol];
                        if (piece && piece.toLowerCase() === 'n' && 
                            ((isDefenderWhite && piece === piece.toLowerCase()) || 
                             (!isDefenderWhite && piece === piece.toUpperCase()))) {
                            return true;
                        }
                    }
                }
                
                // Verificar outras pe√ßas (torres, bispos, rainha, rei)
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],  // Torres e rainha
                    [-1, -1], [-1, 1], [1, -1], [1, 1]  // Bispos e rainha
                ];
                
                for (let [dr, dc] of directions) {
                    let currentRow = row + dr;
                    let currentCol = col + dc;
                    let distance = 1;
                    
                    while (this.isInBounds(currentRow, currentCol)) {
                        const piece = board[currentRow][currentCol];
                        
                        if (piece) {
                            const isAttackerPiece = (isDefenderWhite && piece === piece.toLowerCase()) || 
                                                   (!isDefenderWhite && piece === piece.toUpperCase());
                            
                            if (isAttackerPiece) {
                                const pieceType = piece.toLowerCase();
                                
                                // Rainha ataca em todas as dire√ß√µes
                                if (pieceType === 'q') return true;
                                
                                // Torre ataca em dire√ß√µes retas
                                if (pieceType === 'r' && (dr === 0 || dc === 0)) return true;
                                
                                // Bispo ataca em diagonais
                                if (pieceType === 'b' && dr !== 0 && dc !== 0) return true;
                                
                                // Rei ataca apenas a uma dist√¢ncia de 1
                                if (pieceType === 'k' && distance === 1) return true;
                            }
                            break;
                        }
                        
                        currentRow += dr;
                        currentCol += dc;
                        distance++;
                    }
                }
                
                return false;
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                return this.validMoves.some(([r, c]) => r === toRow && c === toCol);
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                let moveType = 'normal';
                
                // Verificar se √© roque
                if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                    moveType = 'castling';
                }
                
                // Registrar a jogada no hist√≥rico
                this.moveHistory.push({
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol },
                    piece: piece,
                    captured: capturedPiece,
                    type: moveType
                });
                
                // Marcar pe√ßas que se moveram
                this.markPieceAsMoved(fromRow, fromCol);
                
                // Executar movimento especial (roque)
                if (moveType === 'castling') {
                    this.executeCastling(fromRow, fromCol, toRow, toCol);
                } else {
                    // Capturar pe√ßa se houver
                    if (capturedPiece) {
                        const capturedColor = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
                        this.capturedPieces[capturedColor].push(capturedPiece);
                        
                        // Atualizar pontua√ß√£o
                        const points = this.getPieceValue(capturedPiece);
                        this.scores[this.currentPlayer] += points;
                    }
                    
                    // Mover a pe√ßa
                    this.board[toRow][toCol] = piece;
                    this.board[fromRow][fromCol] = '';
                }
                
                // Trocar jogador
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Verificar xeque e xeque-mate
                this.checkForCheckAndMate();
                
                // Atualizar a interface
                this.initializeBoard();
                this.updateCapturedPieces();
                this.updateScores();
                this.updateMoveHistory();
            }

            executeCastling(kingRow, kingCol, toRow, toCol) {
                const isWhite = this.board[kingRow][kingCol] === 'K';
                
                if (toCol === 6) { // Roque pequeno
                    // Mover rei
                    this.board[kingRow][6] = this.board[kingRow][4];
                    this.board[kingRow][4] = '';
                    
                    // Mover torre
                    this.board[kingRow][5] = this.board[kingRow][7];
                    this.board[kingRow][7] = '';
                    
                    // Marcar torre como movida
                    this.markPieceAsMoved(kingRow, 7);
                    
                } else if (toCol === 2) { // Roque grande
                    // Mover rei
                    this.board[kingRow][2] = this.board[kingRow][4];
                    this.board[kingRow][4] = '';
                    
                    // Mover torre
                    this.board[kingRow][3] = this.board[kingRow][0];
                    this.board[kingRow][0] = '';
                    
                    // Marcar torre como movida
                    this.markPieceAsMoved(kingRow, 0);
                }
            }

            getPieceValue(piece) {
                const values = {
                    'p': 1, 'P': 1,
                    'n': 3, 'N': 3,
                    'b': 3, 'B': 3,
                    'r': 5, 'R': 5,
                    'q': 9, 'Q': 9,
                    'k': 0, 'K': 0
                };
                return values[piece] || 0;
            }

            checkForCheckAndMate() {
                // Encontrar a posi√ß√£o do rei do jogador atual
                const kingPiece = this.currentPlayer === 'white' ? 'K' : 'k';
                let kingRow, kingCol;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] === kingPiece) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                }
                
                // Verificar se o rei est√° em xeque
                this.checkStatus[this.currentPlayer] = this.isSquareAttacked(kingRow, kingCol, this.currentPlayer);
                
                // Verificar xeque-mate
                if (this.checkStatus[this.currentPlayer]) {
                    const hasValidMoves = this.hasAnyValidMove();
                    if (!hasValidMoves) {
                        this.gameOver = true;
                    }
                }
            }

            hasAnyValidMove() {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && ((this.currentPlayer === 'white' && piece === piece.toUpperCase()) || 
                                      (this.currentPlayer === 'black' && piece === piece.toLowerCase()))) {
                            const validMoves = this.getValidMoves(row, col);
                            if (validMoves.length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            updateGameStatus() {
                const statusElement = document.getElementById('gameStatus');
                
                if (this.gameOver) {
                    const winner = this.currentPlayer === 'white' ? 'Pretas' : 'Brancas';
                    statusElement.textContent = `Xeque-Mate! ${winner} vencem!`;
                    statusElement.className = 'status checkmate';
                } else if (this.checkStatus[this.currentPlayer]) {
                    statusElement.textContent = `Xeque! Turno: ${this.currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
                    statusElement.className = 'status check';
                    
                    // Destacar o rei em xeque
                    const kingPiece = this.currentPlayer === 'white' ? 'K' : 'k';
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            if (this.board[row][col] === kingPiece) {
                                const square = this.getSquareElement(row, col);
                                square.classList.add('check');
                                break;
                            }
                        }
                    }
                } else {
                    statusElement.textContent = `Turno: ${this.currentPlayer === 'white' ? 'Brancas' : 'Pretas'}`;
                    statusElement.className = 'status';
                }
            }

            updateCapturedPieces() {
                const whiteCapturedElement = document.getElementById('whiteCaptured');
                const blackCapturedElement = document.getElementById('blackCaptured');
                
                whiteCapturedElement.innerHTML = '';
                blackCapturedElement.innerHTML = '';
                
                this.capturedPieces.white.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'captured-piece';
                    pieceElement.textContent = this.getPieceSymbol(piece);
                    whiteCapturedElement.appendChild(pieceElement);
                });
                
                this.capturedPieces.black.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'captured-piece';
                    pieceElement.textContent = this.getPieceSymbol(piece);
                    blackCapturedElement.appendChild(pieceElement);
                });
            }

            updateScores() {
                document.getElementById('whiteScore').textContent = this.scores.white;
                document.getElementById('blackScore').textContent = this.scores.black;
            }

            updateMoveHistory() {
                const historyList = document.getElementById('historyList');
                historyList.innerHTML = '';
                
                this.moveHistory.forEach((move, index) => {
                    const moveElement = document.createElement('div');
                    moveElement.style.padding = '5px';
                    moveElement.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                    
                    const pieceSymbol = this.getPieceSymbol(move.piece);
                    const fromFile = String.fromCharCode(97 + move.from.col); // a-h
                    const fromRank = 8 - move.from.row;
                    const toFile = String.fromCharCode(97 + move.to.col);
                    const toRank = 8 - move.to.row;
                    
                    let moveText = `${index + 1}. ${pieceSymbol} ${fromFile}${fromRank} ‚Üí ${toFile}${toRank}`;
                    
                    if (move.captured) {
                        moveText += ` captura ${this.getPieceSymbol(move.captured)}`;
                    }
                    
                    if (move.type === 'castling') {
                        moveText += ' (roque)';
                    }
                    
                    moveElement.textContent = moveText;
                    historyList.appendChild(moveElement);
                });
            }

            resetGame() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedPiece = null;
                this.validMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.scores = { white: 0, black: 0 };
                this.checkStatus = { white: false, black: false };
                this.gameOver = false;
                this.movedPieces.clear();
                this.initializeBoard();
            }

            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastMove = this.moveHistory.pop();
                const { from, to, piece, captured, type } = lastMove;
                
                if (type === 'castling') {
                    // Reverter roque
                    const isWhite = piece === 'K';
                    const kingRow = isWhite ? 7 : 0;
                    
                    if (to.col === 6) { // Roque pequeno
                        this.board[kingRow][4] = this.board[kingRow][6]; // Rei volta
                        this.board[kingRow][7] = this.board[kingRow][5]; // Torre volta
                        this.board[kingRow][6] = '';
                        this.board[kingRow][5] = '';
                    } else if (to.col === 2) { // Roque grande
                        this.board[kingRow][4] = this.board[kingRow][2]; // Rei volta
                        this.board[kingRow][0] = this.board[kingRow][3]; // Torre volta
                        this.board[kingRow][2] = '';
                        this.board[kingRow][3] = '';
                    }
                    
                    // Remover marcas de movimento
                    this.movedPieces.delete(`${kingRow},4`);
                    this.movedPieces.delete(`${kingRow},${to.col === 6 ? 7 : 0}`);
                } else {
                    // Reverter movimento normal
                    this.board[from.row][from.col] = piece;
                    this.board[to.row][to.col] = captured || '';
                    
                    // Remover marca de movimento
                    this.movedPieces.delete(`${from.row},${from.col}`);
                    
                    // Reverter pontua√ß√£o se houve captura
                    if (captured) {
                        const capturedColor = captured === captured.toUpperCase() ? 'white' : 'black';
                        this.capturedPieces[capturedColor].pop();
                        
                        const points = this.getPieceValue(captured);
                        const undoPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                        this.scores[undoPlayer] -= points;
                    }
                }
                
                // Voltar para o jogador anterior
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Limpar estados de jogo
                this.gameOver = false;
                this.checkStatus = { white: false, black: false };
                
                // Atualizar interface
                this.initializeBoard();
                this.updateCapturedPieces();
                this.updateScores();
                this.updateMoveHistory();
            }
        }

        // Inicializar o jogo
        const chessGame = new ChessGame();
    </script>
</body>
</html>


