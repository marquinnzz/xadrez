<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo de Xadrez - Com IA e Multijogador</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: #5F9EA0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #222;
    user-select: none;
  }
  h1 {
    margin-bottom: 15px;
    color: #fff;
    text-shadow: 0 0 3px #333;
  }
  #game-container {
    display: flex;
    gap: 25px;
  }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
  .square {
    width: 60px;
    height: 60px;
    position: relative;
    font-size: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
  }
  .light {
    background-color: #f0d9b5;
  }
  .dark {
    background-color: #b58863;
  }
  .highlight {
    position: absolute;
    width: 18px;
    height: 18px;
    background-color: #2ecc71cc; /* verde translúcido */
    border-radius: 50%;
    bottom: 8px;
    right: 8px;
    pointer-events: none;
  }
  .selected {
    outline: 3px solid #27ae60;
  }
  .check {
    outline: 3px solid #e74c3c !important;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 230px;
    background: #fff9;
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 0 10px #222a;
  }
  #captured-pieces {
    display: flex;
    flex-direction: column;
    gap: 25px;
    font-size: 20px;
    color: #222;
  }
  .captured-section {
    border-bottom: 1px solid #ccc;
    padding-bottom: 10px;
  }
  .captured-title {
    font-weight: bold;
    margin-bottom: 8px;
    text-align: center;
    font-size: 22px;
  }
  .captured-pieces-list {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
  }
  .captured-piece {
    font-size: 30px;
    user-select: none;
  }
  #buttons {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  button {
    background-color: #27ae60;
    border: none;
    padding: 12px 10px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: 700;
    cursor: pointer;
    color: white;
    transition: background-color 0.3s ease;
  }
  button:hover:not(:disabled) {
    background-color: #219150;
  }
  button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
    color: #eee;
  }
</style>
</head>
<body>

<h1>Jogo de Xadrez</h1>
<div id="game-container">
  <div id="chessboard"></div>
  <div id="sidebar">
    <div id="captured-pieces">
      <div class="captured-section" id="captured-white">
        <div class="captured-title">Peças capturadas das Brancas</div>
        <div class="captured-pieces-list" id="captured-white-list"></div>
      </div>
      <div class="captured-section" id="captured-black">
        <div class="captured-title">Peças capturadas das Pretas</div>
        <div class="captured-pieces-list" id="captured-black-list"></div>
      </div>
    </div>
    <div id="buttons">
      <button id="btn-restart">Reiniciar jogo</button>
      <button id="btn-ai" disabled>Jogar contra IA</button>
      <button id="btn-friend">Jogar com amigo</button>
    </div>
  </div>
</div>

<script>
  const pieces = {
    'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
    'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
  };

  let board;
  let selected = null;
  let turn;
  let gameOver;
  let capturedWhite;
  let capturedBlack;
  let mode = 'friend'; // default modo multijogador

  const boardDiv = document.getElementById('chessboard');
  const capturedWhiteList = document.getElementById('captured-white-list');
  const capturedBlackList = document.getElementById('captured-black-list');
  const btnRestart = document.getElementById('btn-restart');
  const btnAI = document.getElementById('btn-ai');
  const btnFriend = document.getElementById('btn-friend');

  function initGame() {
    board = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];
    selected = null;
    turn = 'white';
    gameOver = false;
    capturedWhite = [];
    capturedBlack = [];
    btnAI.disabled = mode === 'ai';
    btnFriend.disabled = mode === 'friend';
    createBoard();
  }

  function findKing(color) {
    const kingChar = color === 'white' ? 'K' : 'k';
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] === kingChar) return [r,c];
      }
    }
    return null;
  }

  function isInCheck(color) {
    const kingPos = findKing(color);
    if(!kingPos) return false;

    const opponent = color === 'white' ? 'black' : 'white';

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], opponent)) {
          const moves = getValidMovesRaw(r, c, true);
          if(moves.some(m => m[0] === kingPos[0] && m[1] === kingPos[1])) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function isPieceColor(piece, color) {
    if(color === 'white') return piece === piece.toUpperCase();
    return piece === piece.toLowerCase();
  }

  function createBoard() {
    boardDiv.innerHTML = '';
    const inCheck = isInCheck(turn);
    const kingPos = findKing(turn);

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        const square = document.createElement('div');
        square.classList.add('square');
        square.classList.add((r+c)%2 === 0 ? 'light' : 'dark');
        square.dataset.row = r;
        square.dataset.col = c;

        const piece = board[r][c];
        if(piece) {
          square.textContent = pieces[piece];
          square.style.color = (piece === piece.toUpperCase()) ? '#fff' : '#000';
          square.style.textShadow = (piece === piece.toUpperCase()) ? '0 0 3px #000' : 'none';
        }

        if(inCheck && kingPos && kingPos[0] === r && kingPos[1] === c) {
          square.classList.add('check');
        }

        square.addEventListener('click', () => onSquareClick(r,c));
        boardDiv.appendChild(square);
      }
    }
    updateCapturedDisplay();

    if(selected) highlightMoves(selected[0], selected[1]);
  }

  function getValidMovesRaw(row, col, ignoreCheck=false) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    const moves = [];

    switch(piece.toLowerCase()) {
      case 'p':
        const dir = isWhite ? -1 : 1;
        if(inBounds(row + dir, col) && !board[row + dir][col]) {
          moves.push([row + dir, col]);
          if((isWhite && row === 6 || !isWhite && row === 1) && !board[row + 2*dir][col]) {
            moves.push([row + 2*dir, col]);
          }
        }
        if(inBounds(row + dir, col -1) && board[row + dir][col -1] && isOpponentPiece(board[row + dir][col -1], isWhite)) {
          moves.push([row + dir, col -1]);
        }
        if(inBounds(row + dir, col +1) && board[row + dir][col +1] && isOpponentPiece(board[row + dir][col +1], isWhite)) {
          moves.push([row + dir, col +1]);
        }
        break;
      case 'r':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1]]));
        break;
      case 'n':
        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        knightMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
      case 'b':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'q':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'k':
        const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        kingMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
    }
    return moves;
  }

  function getValidMoves(row, col) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    let rawMoves = getValidMovesRaw(row, col);

    const legalMoves = rawMoves.filter(([r,c]) => {
      const backupFrom = board[row][col];
      const backupTo = board[r][c];

      board[r][c] = board[row][col];
      board[row][col] = '';

      const inCheck = isInCheck(isWhite ? 'white' : 'black');

      board[row][col] = backupFrom;
      board[r][c] = backupTo;

      return !inCheck;
    });

    return legalMoves;
  }

  function onSquareClick(row, col) {
    if(gameOver) return;

    const piece = board[row][col];
    if(selected) {
      const moves = getValidMoves(selected[0], selected[1]);
      if(moves.some(m => m[0] === row && m[1] === col)) {
        makeMove(selected[0], selected[1], row, col);
        selected = null;
        createBoard();

        if(gameOver) return;

        if(mode === 'ai') {
          turn = turn === 'white' ? 'black' : 'white';
          if(turn === 'black') {
            setTimeout(computerMove, 600);
          }
        } else if(mode === 'friend') {
          turn = turn === 'white' ? 'black' : 'white';
        }
      } else {
        if(piece && isPieceTurn(piece)) {
          selected = [row,col];
          createBoard();
          highlightMoves(selected[0], selected[1]);
        } else {
          selected = null;
          createBoard();
        }
      }
    } else {
      if(piece && isPieceTurn(piece)) {
        selected = [row,col];
        createBoard();
        highlightMoves(row,col);
      }
    }
  }

  function isPieceTurn(piece) {
    if(turn === 'white') return piece === piece.toUpperCase();
    else return piece === piece.toLowerCase();
  }

  function highlightMoves(row, col) {
    const squares = boardDiv.children;
    const moves = getValidMoves(row, col);

    const indexSelected = row * 8 + col;
    squares[indexSelected].classList.add('selected');

    moves.forEach(move => {
      const idx = move[0]*8 + move[1];
      const highlight = document.createElement('div');
      highlight.classList.add('highlight');
      squares[idx].appendChild(highlight);
    });
  }

  function getLinearMoves(row, col, isWhite, directions) {
    const moves = [];
    for(const [dr,dc] of directions) {
      let nr = row + dr;
      let nc = col + dc;
      while(inBounds(nr,nc)) {
        if(!board[nr][nc]) {
          moves.push([nr,nc]);
        } else {
          if(isOpponentPiece(board[nr][nc], isWhite)) {
            moves.push([nr,nc]);
          }
          break;
        }
        nr += dr;
        nc += dc;
      }
    }
    return moves;
  }

  function isOpponentPiece(piece, isWhite) {
    return isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase();
  }

  function inBounds(r,c) {
    return r>=0 && r<8 && c>=0 && c<8;
  }

  function makeMove(fromR, fromC, toR, toC) {
    const captured = board[toR][toC];
    if(captured) {
      if(captured === captured.toUpperCase()) capturedWhite.push(captured);
      else capturedBlack.push(captured);
    }
    board[toR][toC] = board[fromR][fromC];
    board[fromR][fromC] = '';

    // Verificar promoção do peão
    if(board[toR][toC].toLowerCase() === 'p') {
      if((toR === 0 && board[toR][toC] === 'P') || (toR === 7 && board[toR][toC] === 'p')) {
        board[toR][toC] = board[toR][toC] === 'P' ? 'Q' : 'q';
      }
    }

    // Verifica xeque-mate ou empate
    if(isCheckmate(turn === 'white' ? 'black' : 'white')) {
      alert(`Xeque-mate! ${turn === 'white' ? 'Brancas' : 'Pretas'} venceram!`);
      gameOver = true;
    } else if(isStalemate(turn === 'white' ? 'black' : 'white')) {
      alert('Empate por afogamento!');
      gameOver = true;
    }
  }

  function isCheckmate(color) {
    if(!isInCheck(color)) return false;

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], color)) {
          const moves = getValidMoves(r, c);
          if(moves.length > 0) return false;
        }
      }
    }
    return true;
  }