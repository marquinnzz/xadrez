<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Jogo de Xadrez</title>
  <style>
    body {
      background-color: #4682B4;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      color: white;
      margin: 0;
      padding: 20px;
    }

    h1 {
      margin-bottom: 10px;
    }

    .scoreboard {
      display: flex;
      gap: 50px;
      margin-bottom: 20px;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 3px solid #000;
    }

    .cell {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      position: relative;
    }

    .light {
      background-color: #F4A460;
    }

    .dark {
      background-color: #A0522D;
    }

    .highlight {
      outline: 3px solid yellow;
    }

    .score {
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>Jogo de Xadrez</h1>
  <div class="scoreboard">
    <div id="white-score" class="score">Brancas: 0</div>
    <div id="black-score" class="score">Pretas: 0</div>
  </div>
  <div class="board" id="board"></div>

  <script>
    const boardElement = document.getElementById('board');
    const whiteScoreEl = document.getElementById('white-score');
    const blackScoreEl = document.getElementById('black-score');

    // Valores das peças
    const pieceValues = {
      p: 1,
      r: 5,
      n: 3,
      b: 3,
      q: 9,
      k: 0
    };

    let whiteScore = 0;
    let blackScore = 0;

    // Unicode das peças
    const pieces = {
      'r': '♜',
      'n': '♞',
      'b': '♝',
      'q': '♛',
      'k': '♚',
      'p': '♟',
      'R': '♖',
      'N': '♘',
      'B': '♗',
      'Q': '♕',
      'K': '♔',
      'P': '♙'
    };

    let board = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];

    let selected = null;

    function isWhite(piece) {
      return piece === piece.toUpperCase();
    }

    function renderBoard() {
      boardElement.innerHTML = '';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
          cell.dataset.row = row;
          cell.dataset.col = col;

          const piece = board[row][col];
          if (piece) {
            cell.textContent = pieces[piece];
          }

          cell.addEventListener('click', () => onCellClick(row, col));
          boardElement.appendChild(cell);
        }
      }

      if (selected) {
        highlightMoves(selected.row, selected.col);
      }
    }

    function onCellClick(row, col) {
      const piece = board[row][col];

      if (selected) {
        const fromRow = selected.row;
        const fromCol = selected.col;
        const selectedPiece = board[fromRow][fromCol];

        if ((fromRow !== row || fromCol !== col) && isValidMove(fromRow, fromCol, row, col)) {
          // Captura
          const target = board[row][col];
          if (target) {
            const value = pieceValues[target.toLowerCase()] || 0;
            if (isWhite(selectedPiece)) {
              whiteScore += value;
              whiteScoreEl.textContent = `Brancas: ${whiteScore}`;
            } else {
              blackScore += value;
              blackScoreEl.textContent = `Pretas: ${blackScore}`;
            }
          }

          board[row][col] = selectedPiece;
          board[fromRow][fromCol] = '';
        }

        selected = null;
        renderBoard();
      } else {
        if (piece) {
          selected = { row, col };
          renderBoard();
        }
      }
    }

    function highlightMoves(row, col) {
      const cells = document.querySelectorAll('.cell');
      const currentPiece = board[row][col];
      const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [-1, 1], [1, -1], [1, 1]
      ];

      cells.forEach(cell => {
        const r = parseInt(cell.dataset.row);
        const c = parseInt(cell.dataset.col);

        if ((r !== row || c !== col) && isValidMove(row, col, r, c)) {
          cell.classList.add('highlight');
        }
      });
    }

    function isValidMove(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      const target = board[toRow][toCol];

      // Não permitir capturar a própria peça
      if (target && isWhite(piece) === isWhite(target)) return false;

      // Apenas movimentos básicos (sem regras completas)
      const dx = toCol - fromCol;
      const dy = toRow - fromRow;

      const p = piece.toLowerCase();

      switch (p) {
        case 'p':
          const dir = isWhite(piece) ? -1 : 1;
          if (dx === 0 && !target && dy === dir) return true;
          if (Math.abs(dx) === 1 && dy === dir && target) return true;
          break;
        case 'r':
          return (dx === 0 || dy === 0);
        case 'n':
          return (Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2);
        case 'b':
          return Math.abs(dx) === Math.abs(dy);
        case 'q':
          return (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy));
        case 'k':
          return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;
      }
      return false;
    }

    renderBoard();
  </script>
</body>
</html>
