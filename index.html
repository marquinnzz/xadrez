<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo de Xadrez vs Máquina</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: #5F9EA0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    user-select: none;
  }
  #game-container {
    display: flex;
    gap: 20px;
  }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
  .square {
    width: 60px;
    height: 60px;
    position: relative;
    font-size: 42px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
  }
  .light {
    background-color: #eeeed2;
  }
  .dark {
    background-color: #769656;
  }
  .highlight {
    position: absolute;
    width: 15px;
    height: 15px;
    background-color: rgba(46, 204, 113, 0.8);
    border-radius: 50%;
    bottom: 8px;
    right: 8px;
    pointer-events: none;
  }
  .selected {
    outline: 3px solid #2ecc71;
  }
  .check {
    outline: 3px solid #e74c3c !important;
  }
  #captured-pieces {
    display: flex;
    flex-direction: column;
    gap: 30px;
    font-size: 20px;
  }
  .captured-section {
    background: rgba(255, 255, 255, 0.15);
    padding: 10px;
    border-radius: 8px;
    width: 160px;
  }
  .captured-title {
    font-weight: bold;
    margin-bottom: 8px;
    text-align: center;
    font-size: 24px;
  }
  .captured-pieces-list {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 6px;
  }
  .captured-piece {
    font-size: 28px;
    user-select: none;
  }
</style>
</head>
<body>

<h1>Jogo de Xadrez - Você (Brancas) vs Máquina (Pretas)</h1>
<div id="game-container">
  <div id="chessboard"></div>
  <div id="captured-pieces">
    <div class="captured-section" id="captured-white">
      <div class="captured-title">Peças capturadas das Brancas</div>
      <div class="captured-pieces-list" id="captured-white-list"></div>
    </div>
    <div class="captured-section" id="captured-black">
      <div class="captured-title">Peças capturadas das Pretas</div>
      <div class="captured-pieces-list" id="captured-black-list"></div>
    </div>
  </div>
</div>

<script>
  const pieces = {
    'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
    'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
  };

  let board = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R']
  ];

  const boardDiv = document.getElementById('chessboard');
  const capturedWhiteList = document.getElementById('captured-white-list');
  const capturedBlackList = document.getElementById('captured-black-list');

  let selected = null;
  let turn = 'white'; // jogador humano é branco
  let gameOver = false;

  // Guardar peças capturadas
  let capturedWhite = [];
  let capturedBlack = [];

  function findKing(color) {
    const kingChar = color === 'white' ? 'K' : 'k';
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] === kingChar) return [r,c];
      }
    }
    return null;
  }

  function isInCheck(color) {
    const kingPos = findKing(color);
    if(!kingPos) return false;

    const opponent = color === 'white' ? 'black' : 'white';

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], opponent)) {
          const moves = getValidMovesRaw(r, c, true);
          if(moves.some(m => m[0] === kingPos[0] && m[1] === kingPos[1])) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function isPieceColor(piece, color) {
    if(color === 'white') return piece === piece.toUpperCase();
    return piece === piece.toLowerCase();
  }

  function createBoard() {
    boardDiv.innerHTML = '';
    const inCheck = isInCheck(turn);
    const kingPos = findKing(turn);

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        const square = document.createElement('div');
        square.classList.add('square');
        square.classList.add((r+c)%2 === 0 ? 'light' : 'dark');
        square.dataset.row = r;
        square.dataset.col = c;

        const piece = board[r][c];
        if(piece) {
          square.textContent = pieces[piece];
          square.style.color = (piece === piece.toUpperCase()) ? 'white' : 'black';
          square.style.textShadow = (piece === piece.toUpperCase()) ? '0 0 3px black' : 'none';
        }

        if(inCheck && kingPos && kingPos[0] === r && kingPos[1] === c) {
          square.classList.add('check');
        }

        square.addEventListener('click', () => onSquareClick(r,c));
        boardDiv.appendChild(square);
      }
    }
    updateCapturedDisplay();
  }

  function getValidMovesRaw(row, col, ignoreCheck=false) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    const moves = [];

    switch(piece.toLowerCase()) {
      case 'p':
        const dir = isWhite ? -1 : 1;
        if(inBounds(row + dir, col) && !board[row + dir][col]) {
          moves.push([row + dir, col]);
          if((isWhite && row === 6 || !isWhite && row === 1) && !board[row + 2*dir][col]) {
            moves.push([row + 2*dir, col]);
          }
        }
        if(inBounds(row + dir, col -1) && board[row + dir][col -1] && isOpponentPiece(board[row + dir][col -1], isWhite)) {
          moves.push([row + dir, col -1]);
        }
        if(inBounds(row + dir, col +1) && board[row + dir][col +1] && isOpponentPiece(board[row + dir][col +1], isWhite)) {
          moves.push([row + dir, col +1]);
        }
        break;
      case 'r':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1]]));
        break;
      case 'n':
        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        knightMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
      case 'b':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'q':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'k':
        const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        kingMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
    }
    return moves;
  }

  function getValidMoves(row, col) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    let rawMoves = getValidMovesRaw(row, col);

    const legalMoves = rawMoves.filter(([r,c]) => {
      const backupFrom = board[row][col];
      const backupTo = board[r][c];

      board[r][c] = board[row][col];
      board[row][col] = '';

      const inCheck = isInCheck(isWhite ? 'white' : 'black');

      board[row][col] = backupFrom;
      board[r][c] = backupTo;

      return !inCheck;
    });

    return legalMoves;
  }

  function onSquareClick(row, col) {
    if(gameOver) return;
    if(turn !== 'white') return; // só o humano (branco) joga clicando

    const piece = board[row][col];

    if(selected) {
      const moves = getValidMoves(selected[0], selected[1]);
      if(moves.some(m => m[0] === row && m[1] === col)) {
        makeMove(selected[0], selected[1], row, col);
        selected = null;
        createBoard();

        if(gameOver) return;

        turn = 'black';
        setTimeout(computerMove, 500);
      } else {
        if(piece && isPieceTurn(piece)) {
          selected = [row,col];
          createBoard();
          highlightMoves(selected[0], selected[1]);
        } else {
          selected = null;
          createBoard();
        }
      }
    } else {
      if(piece && isPieceTurn(piece)) {
        selected = [row,col];
        createBoard();
        highlightMoves(row,col);
      }
    }
  }

  function isPieceTurn(piece) {
    if(turn === 'white') return piece === piece.toUpperCase();
    else return piece === piece.toLowerCase();
  }

  function highlightMoves(row, col) {
    const squares = boardDiv.children;
    const moves = getValidMoves(row, col);

    const indexSelected = row * 8 + col;
    squares[indexSelected].classList.add('selected');

    moves.forEach(move => {
      const idx = move[0]*8 + move[1];
      const highlight = document.createElement('div');
      highlight.classList.add('highlight');
      squares[idx].appendChild(highlight);
    });
  }

  function getLinearMoves(row, col, isWhite, directions) {
    const moves = [];
    for(const [dr,dc] of directions) {
      let nr = row + dr;
      let nc = col + dc;
      while(inBounds(nr,nc)) {
        if(!board[nr][nc]) {
          moves.push([nr,nc]);
        } else {
          if(isOpponentPiece(board[nr][nc], isWhite)) {
            moves.push([nr,nc]);
          }
          break;
        }
        nr += dr;
        nc += dc;
      }
    }
    return moves;
  }

  function isOpponentPiece(piece, isWhite) {
    return isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase();
  }

  function inBounds(r,c) {
    return r>=0 && r<8 && c>=0 && c<8;
  }

  function makeMove(fromR, fromC, toR, toC) {
    const captured = board[toR][toC];
    if(captured) {
      // Guarda a peça capturada
      if(captured === captured.toUpperCase()) capturedWhite.push(captured);
      else capturedBlack.push(captured);
    }
    board[toR][toC] = board[fromR][fromC];
    board[fromR][fromC] = '';

    if(isInCheck(turn === 'white' ? 'black' : 'white')) {
      // Alerta de xeque para o adversário
      // Mas só mostramos alerta pro humano (branco)
      if(turn === 'white') alert('Máquina está em XEQUE!');
      else alert('Você está em XEQUE!');
    }

    if(checkMate(turn === 'white' ? 'black' : 'white')) {
      alert((turn === 'white' ? 'Máquina' : 'Você') + ' foi MATE! Fim de jogo.');
      gameOver = true;
    }
  }

  // Implementa um checagem simples de mate: não tem movimentos legais e está em xeque
  function checkMate(color) {
    if(!isInCheck(color)) return false;

    // Verifica se existe algum movimento legal para o jogador da cor
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], color)) {
          const moves = getValidMoves(r, c);
          if(moves.length > 0) return false;
        }
      }
    }
    return true;
  }

  // Função que executa jogada da máquina (preto)
  function computerMove() {
    if(gameOver) return;

    // Pega todas peças pretas e movimentos legais
    const allMoves = [];
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], 'black')) {
          const moves = getValidMoves(r, c);
          moves.forEach(mv => allMoves.push({from: [r,c], to: mv}));
        }
      }
    }

    if(allMoves.length === 0) {
      if(isInCheck('black')) {
        alert('Você ganhou! Máquina está em mate!');
      } else {
        alert('Empate por falta de movimentos!');
      }
      gameOver = true;
      return;
    }

    // Escolhe uma jogada aleatória (pode ser melhorada depois)
    const choice = allMoves[Math.floor(Math.random() * allMoves.length)];

    makeMove(choice.from[0], choice.from[1], choice.to[0], choice.to[1]);
    turn = 'white';
    createBoard();
  }

  function updateCapturedDisplay() {
    capturedWhiteList.innerHTML = '';
    capturedBlackList.innerHTML = '';

    capturedWhite.forEach(piece => {
      const span = document.createElement('span');
      span.classList.add('captured-piece');
      span.textContent = pieces[piece];
      span.style.color = 'white';
      capturedWhiteList.appendChild(span);
    });

    capturedBlack.forEach(piece => {
      const span = document.createElement('span');
      span.classList.add('captured-piece');
      span.textContent = pieces[piece];
      span.style.color = 'black';
      capturedBlackList.appendChild(span);
    });
  }

  createBoard();
</script>

</body>
</html>
