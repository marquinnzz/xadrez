<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo de Xadrez com Xeque</title>
<style>
  body {
    display: flex;
    justify-content: center;
    padding: 20px;
    background: #f0f0f0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
  }
  .square {
    width: 60px;
    height: 60px;
    position: relative;
    font-size: 42px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
  }
  .light {
    background-color: #eeeed2;
  }
  .dark {
    background-color: #769656;
  }
  .highlight {
    position: absolute;
    width: 15px;
    height: 15px;
    background-color: rgba(46, 204, 113, 0.8);
    border-radius: 50%;
    bottom: 8px;
    right: 8px;
    pointer-events: none;
  }
  .selected {
    outline: 3px solid #2ecc71;
  }
  .check {
    outline: 3px solid #e74c3c !important; /* destaque vermelho para o rei em xeque */
  }
</style>
</head>
<body>

<div id="chessboard"></div>

<script>
  const pieces = {
    'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
    'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
  };

  let board = [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R']
  ];

  const boardDiv = document.getElementById('chessboard');

  let selected = null;
  let turn = 'white';

  // Armazenar posição do rei para checar xeque rápido
  function findKing(color) {
    const kingChar = color === 'white' ? 'K' : 'k';
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] === kingChar) return [r,c];
      }
    }
    return null;
  }

  // Verifica se a cor 'color' está em xeque
  function isInCheck(color) {
    const kingPos = findKing(color);
    if(!kingPos) return false; // Rei capturado, teoricamente fim do jogo

    // Verificar se alguma peça adversária ataca o rei
    const opponent = color === 'white' ? 'black' : 'white';

    // Vamos checar se algum movimento do adversário pode atacar o rei
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], opponent)) {
          const moves = getValidMovesRaw(r, c, true);
          if(moves.some(m => m[0] === kingPos[0] && m[1] === kingPos[1])) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // Função auxiliar para validar cor da peça
  function isPieceColor(piece, color) {
    if(color === 'white') return piece === piece.toUpperCase();
    return piece === piece.toLowerCase();
  }

  function createBoard() {
    boardDiv.innerHTML = '';
    const inCheck = isInCheck(turn);
    const kingPos = findKing(turn);

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        const square = document.createElement('div');
        square.classList.add('square');
        square.classList.add((r+c)%2 === 0 ? 'light' : 'dark');
        square.dataset.row = r;
        square.dataset.col = c;

        const piece = board[r][c];
        if(piece) {
          square.textContent = pieces[piece];
          square.style.color = (piece === piece.toUpperCase()) ? 'white' : 'black';
          square.style.textShadow = (piece === piece.toUpperCase()) ? '0 0 3px black' : 'none';
        }

        // Se rei está em xeque, destacar o rei
        if(inCheck && kingPos && kingPos[0] === r && kingPos[1] === c) {
          square.classList.add('check');
        }

        square.addEventListener('click', () => onSquareClick(r,c));
        boardDiv.appendChild(square);
      }
    }
  }

  // Esta versão de getValidMoves ignora o xeque para gerar movimentos base
  function getValidMovesRaw(row, col, ignoreCheck=false) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    const moves = [];

    switch(piece.toLowerCase()) {
      case 'p':
        const dir = isWhite ? -1 : 1;
        if(inBounds(row + dir, col) && !board[row + dir][col]) {
          moves.push([row + dir, col]);
          if((isWhite && row === 6 || !isWhite && row === 1) && !board[row + 2*dir][col]) {
            moves.push([row + 2*dir, col]);
          }
        }
        if(inBounds(row + dir, col -1) && board[row + dir][col -1] && isOpponentPiece(board[row + dir][col -1], isWhite)) {
          moves.push([row + dir, col -1]);
        }
        if(inBounds(row + dir, col +1) && board[row + dir][col +1] && isOpponentPiece(board[row + dir][col +1], isWhite)) {
          moves.push([row + dir, col +1]);
        }
        break;
      case 'r':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1]]));
        break;
      case 'n':
        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        knightMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
      case 'b':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'q':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'k':
        const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        kingMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
    }
    return moves;
  }

  // Função que filtra os movimentos que deixariam o rei em xeque
  function getValidMoves(row, col) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    let rawMoves = getValidMovesRaw(row, col);

    // Para cada movimento, simulamos o movimento e verificamos se fica em xeque
    const legalMoves = rawMoves.filter(([r,c]) => {
      // copia do tabuleiro para simulação
      const backupFrom = board[row][col];
      const backupTo = board[r][c];

      board[r][c] = board[row][col];
      board[row][col] = '';

      const inCheck = isInCheck(isWhite ? 'white' : 'black');

      // desfaz a simulação
      board[row][col] = backupFrom;
      board[r][c] = backupTo;

      return !inCheck;
    });

    return legalMoves;
  }

  function onSquareClick(row, col) {
    const piece = board[row][col];

    if(selected) {
      const moves = getValidMoves(selected[0], selected[1]);
      if(moves.some(m => m[0] === row && m[1] === col)) {
        movePiece(selected[0], selected[1], row, col);
        selected = null;
        turn = turn === 'white' ? 'black' : 'white';

        // Verifica se o próximo jogador está em xeque
        if(isInCheck(turn)) {
          alert(turn.toUpperCase() + ' está em XEQUE!');
          // TODO: aqui pode implementar xeque-mate no futuro
        }
        createBoard();
      } else {
        // Seleciona outra peça do jogador, se possível
        if(piece && isPieceTurn(piece)) {
          selected = [row,col];
          createBoard();
          highlightMoves(selected[0], selected[1]);
        } else {
          selected = null;
          createBoard();
        }
      }
    } else {
      if(piece && isPieceTurn(piece)) {
        selected = [row,col];
        createBoard();
        highlightMoves(row,col);
      }
    }
  }

  function isPieceTurn(piece) {
    if(turn === 'white') return piece === piece.toUpperCase();
    else return piece === piece.toLowerCase();
  }

  function highlightMoves(row, col) {
    const squares = boardDiv.children;
    const moves = getValidMoves(row, col);

    // Selecionar o quadrado da peça
    const indexSelected = row * 8 + col;
    squares[indexSelected].classList.add('selected');

    moves.forEach(move => {
      const idx = move[0]*8 + move[1];
      const highlight = document.createElement('div');
      highlight.classList.add('highlight');
      squares[idx].appendChild(highlight);
    });
  }

  function getLinearMoves(row, col, isWhite, directions) {
    const moves = [];
    for(const [dr,dc] of directions) {
      let nr = row + dr;
      let nc = col + dc;
      while(inBounds(nr,nc)) {
        if(!board[nr][nc]) {
          moves.push([nr,nc]);
        } else {
          if(isOpponentPiece(board[nr][nc], isWhite)) {
            moves.push([nr,nc]);
          }
          break;
        }
        nr += dr;
        nc += dc;
      }
    }
    return moves;
  }

  function isOpponentPiece(piece, isWhite) {
    return isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase();
  }

  function inBounds(r,c) {
    return r>=0 && r<8 && c>=0 && c<8;
  }

  function movePiece(fromR, fromC, toR, toC) {
    board[toR][toC] = board[fromR][fromC];
    board[fromR][fromC] = '';
  }

  createBoard();
</script>

</body>
</html>
