<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo de Xadrez - Com IA e Multijogador</title>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: #5F9EA0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    user-select: none;
  }
  h1 {
    margin-bottom: 10px;
  }
  #game-container {
    display: flex;
    gap: 20px;
  }
  #chessboard {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid #333;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
  .square {
    width: 60px;
    height: 60px;
    position: relative;
    font-size: 42px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
  }
  .light {
    background-color: #eeeed2;
  }
  .dark {
    background-color: #769656;
  }
  .highlight {
    position: absolute;
    width: 15px;
    height: 15px;
    background-color: rgba(46, 204, 113, 0.8);
    border-radius: 50%;
    bottom: 8px;
    right: 8px;
    pointer-events: none;
  }
  .selected {
    outline: 3px solid #2ecc71;
  }
  .check {
    outline: 3px solid #e74c3c !important;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 200px;
  }
  #captured-pieces {
    display: flex;
    flex-direction: column;
    gap: 30px;
    font-size: 20px;
    background: rgba(255, 255, 255, 0.15);
    padding: 15px;
    border-radius: 8px;
  }
  .captured-section {
    /* border: 1px solid #fff; */
  }
  .captured-title {
    font-weight: bold;
    margin-bottom: 8px;
    text-align: center;
    font-size: 24px;
  }
  .captured-pieces-list {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 6px;
  }
  .captured-piece {
    font-size: 28px;
    user-select: none;
  }
  #buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  button {
    background-color: #2ecc71;
    border: none;
    padding: 10px;
    border-radius: 6px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    color: #1a1a1a;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: #27ae60;
  }
  button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
    color: #444;
  }
</style>
</head>
<body>

<h1>Jogo de Xadrez</h1>
<div id="game-container">
  <div id="chessboard"></div>
  <div id="sidebar">
    <div id="captured-pieces">
      <div class="captured-section" id="captured-white">
        <div class="captured-title">Peças capturadas das Brancas</div>
        <div class="captured-pieces-list" id="captured-white-list"></div>
      </div>
      <div class="captured-section" id="captured-black">
        <div class="captured-title">Peças capturadas das Pretas</div>
        <div class="captured-pieces-list" id="captured-black-list"></div>
      </div>
    </div>
    <div id="buttons">
      <button id="btn-restart">Reiniciar jogo</button>
      <button id="btn-ai" disabled>Jogar contra IA</button>
      <button id="btn-friend">Jogar com amigo</button>
    </div>
  </div>
</div>

<script>
  const pieces = {
    'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
    'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
  };

  let board;
  let selected = null;
  let turn;
  let gameOver;
  let capturedWhite;
  let capturedBlack;
  let mode; // 'ai' ou 'friend'

  const boardDiv = document.getElementById('chessboard');
  const capturedWhiteList = document.getElementById('captured-white-list');
  const capturedBlackList = document.getElementById('captured-black-list');
  const btnRestart = document.getElementById('btn-restart');
  const btnAI = document.getElementById('btn-ai');
  const btnFriend = document.getElementById('btn-friend');

  function initGame() {
    board = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['','','','','','','',''],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];
    selected = null;
    turn = 'white';
    gameOver = false;
    capturedWhite = [];
    capturedBlack = [];
    createBoard();
  }

  function findKing(color) {
    const kingChar = color === 'white' ? 'K' : 'k';
    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] === kingChar) return [r,c];
      }
    }
    return null;
  }

  function isInCheck(color) {
    const kingPos = findKing(color);
    if(!kingPos) return false;

    const opponent = color === 'white' ? 'black' : 'white';

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        if(board[r][c] && isPieceColor(board[r][c], opponent)) {
          const moves = getValidMovesRaw(r, c, true);
          if(moves.some(m => m[0] === kingPos[0] && m[1] === kingPos[1])) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function isPieceColor(piece, color) {
    if(color === 'white') return piece === piece.toUpperCase();
    return piece === piece.toLowerCase();
  }

  function createBoard() {
    boardDiv.innerHTML = '';
    const inCheck = isInCheck(turn);
    const kingPos = findKing(turn);

    for(let r=0; r<8; r++) {
      for(let c=0; c<8; c++) {
        const square = document.createElement('div');
        square.classList.add('square');
        square.classList.add((r+c)%2 === 0 ? 'light' : 'dark');
        square.dataset.row = r;
        square.dataset.col = c;

        const piece = board[r][c];
        if(piece) {
          square.textContent = pieces[piece];
          square.style.color = (piece === piece.toUpperCase()) ? 'white' : 'black';
          square.style.textShadow = (piece === piece.toUpperCase()) ? '0 0 3px black' : 'none';
        }

        if(inCheck && kingPos && kingPos[0] === r && kingPos[1] === c) {
          square.classList.add('check');
        }

        square.addEventListener('click', () => onSquareClick(r,c));
        boardDiv.appendChild(square);
      }
    }
    updateCapturedDisplay();

    if(selected) highlightMoves(selected[0], selected[1]);
  }

  function getValidMovesRaw(row, col, ignoreCheck=false) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    const moves = [];

    switch(piece.toLowerCase()) {
      case 'p':
        const dir = isWhite ? -1 : 1;
        if(inBounds(row + dir, col) && !board[row + dir][col]) {
          moves.push([row + dir, col]);
          if((isWhite && row === 6 || !isWhite && row === 1) && !board[row + 2*dir][col]) {
            moves.push([row + 2*dir, col]);
          }
        }
        if(inBounds(row + dir, col -1) && board[row + dir][col -1] && isOpponentPiece(board[row + dir][col -1], isWhite)) {
          moves.push([row + dir, col -1]);
        }
        if(inBounds(row + dir, col +1) && board[row + dir][col +1] && isOpponentPiece(board[row + dir][col +1], isWhite)) {
          moves.push([row + dir, col +1]);
        }
        break;
      case 'r':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1]]));
        break;
      case 'n':
        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        knightMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
      case 'b':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'q':
        moves.push(...getLinearMoves(row, col, isWhite, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]));
        break;
      case 'k':
        const kingMoves = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        kingMoves.forEach(([dr,dc]) => {
          const nr = row+dr, nc = col+dc;
          if(inBounds(nr,nc)) {
            if(!board[nr][nc] || isOpponentPiece(board[nr][nc], isWhite)) {
              moves.push([nr,nc]);
            }
          }
        });
        break;
    }
    return moves;
  }

  function getValidMoves(row, col) {
    const piece = board[row][col];
    if(!piece) return [];

    const isWhite = piece === piece.toUpperCase();
    let rawMoves = getValidMovesRaw(row, col);

    const legalMoves = rawMoves.filter(([r,c]) => {
      const backupFrom = board[row][col];
      const backupTo = board[r][c];

      board[r][c] = board[row][col];
      board[row][col] = '';

      const inCheck = isInCheck(isWhite ? 'white' : 'black');

      board[row][col] = backupFrom;
      board[r][c] = backupTo;

      return !inCheck;
    });

    return legalMoves;
  }

  function onSquareClick(row, col) {
    if(gameOver) return;

    // Multijogador permite o jogador de vez clicar
    const piece = board[row][col];
    if(selected) {
      const moves = getValidMoves(selected[0], selected[1]);
      if(moves.some(m => m[0] === row && m[1] === col)) {
        makeMove(selected[0], selected[1], row, col);
        selected = null;
        createBoard();

        if(gameOver) return;

        if(mode === 'ai') {
          turn = turn === 'white' ? 'black' : 'white';
          if(turn === 'black') {
            setTimeout(computerMove, 500);
          }
        } else if(mode === 'friend') {
          turn = turn === 'white' ? 'black' : 'white';
        }
      } else {
        if(piece && isPieceTurn(piece)) {
          selected = [row,col];
          createBoard();
          highlightMoves(selected[0], selected[1]);
        } else {
          selected = null;
          createBoard();
        }
      }
    } else {
      if(piece && isPieceTurn(piece)) {
        selected = [row,col];
        createBoard();
        highlightMoves(row,col);
      }
    }
  }

  function isPieceTurn(piece) {
    if(turn === 'white') return piece === piece.toUpperCase();
    else return piece === piece.toLowerCase();
  }

  function highlightMoves(row, col) {
    const squares = boardDiv.children;
    const moves = getValidMoves(row, col);

    const indexSelected = row * 8 + col;
    squares[indexSelected].classList.add('selected');

    moves.forEach(move => {
      const idx = move[0]*8 + move[1];
      const highlight = document.createElement('div');
      highlight.classList.add('highlight');
      squares[idx].appendChild(highlight);
    });
  }

  function getLinearMoves(row, col, isWhite, directions) {
    const moves = [];
    for(const [dr,dc] of directions) {
      let nr = row + dr;
      let nc = col + dc;
      while(inBounds(nr,nc)) {
        if(!board[nr][nc]) {
          moves.push([nr,nc]);
        } else {
          if(isOpponentPiece(board[nr][nc], isWhite)) {
            moves.push([nr,nc]);
          }
          break;
        }
        nr += dr;
        nc += dc;
      }
    }
    return moves;
  }

  function isOpponentPiece(piece, isWhite) {
    return isWhite ? piece === piece.toLowerCase() : piece === piece.toUpperCase();
  }

  function inBounds(r,c) {
    return r>=0 && r<8 && c>=0 && c<8;
  }

  function makeMove(fromR, fromC, toR, toC) {
    const captured = board[toR][toC];
    if(captured) {
      if(captured === captured.to
